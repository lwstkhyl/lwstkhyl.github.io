---
layout: mypost
title: 使用我的GSE157827数据进行初步分析-3
category: other
subcategory: other-other
---

2026.1.28-2026.2.研究进展

<!-- more -->

### hERV计数

stellarscope：使用`best_average`模式

```sh
module load miniconda3/base
conda activate stellarscope
bam_dir="/public/home/GENE_proc/wth/GSE157827/bam/filter_bam"
stellarscope_dir="/public/home/GENE_proc/wth/GSE157827/stellarscope"
out_root="/public/home/GENE_proc/wth/GSE157827/mtx"
hERV_gtf=/public/home/wangtianhao/Desktop/STAR_ref/transcripts.gtf
for bam in "${bam_dir}"/GSM*Aligned.sortedByCB.bam; do
  GSM=$(basename "$bam" | sed 's/Aligned\.sortedByCB\.bam$//')
  outdir="${stellarscope_dir}/${GSM}/"
  mkdir -p "$outdir"
  stellarscope assign \
    --outdir "$outdir" \
    --nproc 16 \
    --stranded_mode F \
    --whitelist "${out_root}/${GSM}/gene/barcodes.tsv" \
    --pooling_mode individual \
    --reassign_mode best_average \
    --max_iter 500 \
    --updated_sam \
    "$bam" \
    "$hERV_gtf"
  mkdir -p ${out_root}/${GSM}/hERV_new
  cp ${outdir}/stellarscope-barcodes.tsv ${out_root}/${GSM}/hERV_new/${res_barcodes}.tsv
  cp ${outdir}/stellarscope-features.tsv ${out_root}/${GSM}/hERV_new/${res_features}.tsv
  cp ${outdir}/stellarscope-TE_counts.mtx ${out_root}/${GSM}/hERV_new/${res_counts}.mtx
done
```

featureCounts：不提供直接适配单细胞数据的接口（不会按barcode分列，也不做UMI去重），需要结合umi-tools等工具处理（参见[单细胞转录组数据分析流程](https://zhuanlan.zhihu.com/p/652885128)，但这个教程也是针对普通基因的）

scTE：是适配单细胞数据的转座元件分析工具，不过也是需要自己做针对hERV的gtf，相比featureCounts可行性更高

### 计算family-level计数矩阵

构建一个`位点-家族-亚家族`的映射

```r
get_attr <- function(x, key) {
  pat <- paste0(key, ' "([^"]+)"')
  m <- regexec(pat, x, perl = TRUE)
  rr <- regmatches(x, m)
  out <- rep(NA_character_, length(x))
  ok <- lengths(rr) >= 2
  out[ok] <- vapply(rr[ok], `[`, character(1), 2)
  out
}
build_herv_map <- function(gtf_path) {
  lines <- readLines(gtf_path, warn = FALSE)
  lines <- lines[!grepl("^\\s*#", lines)]
  lines <- lines[nzchar(lines)]
  gtf <- data.table::fread(
    text = lines,
    sep = "\t",
    header = FALSE,
    quote = "",
    fill = TRUE,
    data.table = TRUE
  )
  gtf <- gtf[, 1:9]
  setnames(gtf, c("seqname","source","feature","start","end","score","strand","frame","attribute"))
  gtf[, gene_id    := get_attr(attribute, "gene_id")]
  gtf[, locus      := get_attr(attribute, "locus")]
  gtf[, intModel   := get_attr(attribute, "intModel")]
  gtf[, repName    := get_attr(attribute, "repName")]
  gtf[, repFamily  := get_attr(attribute, "repFamily")]
  gtf[, geneRegion := get_attr(attribute, "geneRegion")]
  # gene行：intModel
  gene_dt <- gtf[feature == "gene", .(locus_id = gene_id, intModel)][!is.na(locus_id)]
  # exon行：repFamily/repName/geneRegion
  exon_dt <- gtf[feature == "exon", .(locus_id = gene_id, repFamily, repName, geneRegion)][!is.na(locus_id)]
  # 每个位点的repFamily：取出现最多的repFamily
  repfam_dt <- exon_dt[!is.na(repFamily),
                       .(repFamily = {
                         x <- repFamily
                         ux <- unique(x); ux[which.max(tabulate(match(x, ux)))]
                       }),
                       by = locus_id]
  # subfamily：优先internal exon的repName
  subfam_dt <- exon_dt[geneRegion == "internal" & !is.na(repName),
                       .(subfamily_fallback = repName[1]),
                       by = locus_id]
  map <- merge(gene_dt, repfam_dt, by = "locus_id", all = TRUE)
  map <- merge(map, subfam_dt, by = "locus_id", all = TRUE)
  map[, family := sub("_.*$", "", locus_id)]
  map[, subfamily := fifelse(!is.na(intModel) & nzchar(intModel), intModel, subfamily_fallback)]
  map$subfamily <- gsub("-int", "", map$subfamily)  # 去掉结尾的-int标记
  unique(map[, .(locus_id, family, subfamily, repFamily)])
}
gtf_path <- "C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\metadata\\hERV.gtf"
herv_map <- build_herv_map(gtf_path)
write.csv(herv_map, file = "C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\metadata\\hERV_locus2family.csv", row.names = F)
```

![my_GSE157827_3_1](/upload/md-image/other/my_GSE157827_3_1.png){:width="500px" height="500px"}

gtf文件：

![my_GSE157827_3_2](/upload/md-image/other/my_GSE157827_3_2.png){:width="400px" height="400px"}

各列含义：
- `locus_id`：计数直接得到的feature名，对应gtf中的`gene_id`
- `repFamily`：gtf中的`repFamily`，应该是超家族/大类，只有`ERVK`/`ERVL`/`ERV1`这三种
- `subfamily`：gtf中的`intModel`/`repName`，其中以gene行的intModel优先（如果这个位点在GTF的gene记录里有intModel，就认为它是该位点最核心、最想表达的“内部模型/亚家族标签”，从上面的截图中可以看到，有时一个位点还会有LTR的标记，不过由于计数结果中并没有标明某个读段到底是ltr还是int，就统一都拿int的名字来指代了。如果没有int就用LTR名称
  
  在处理时，因为它们都以`-int`结尾（表示internal模块），为了更美观将其去掉，只保留前面的家族名

- `family`：使用上次的方法，直接从feature名中以`-`为分隔截取的

  经过对比，其实subfamily和前面直接按`-`分隔的结果差不多，主要的区别是有些subfamily的名称不一致，比如`HML1`在这次的聚合方法中变成了`HERVK14`（`HMLx`->`HERVKx`）

我还找了当时用featureCounts得到的结果，其实家族名也都是

```
HERV16 HERV9N HERVIP10F HERVL HERVK13 HERVL40
HERVH HERVL66 HERVFH21 HERV9 HERVFH19 HERVIP10FH
HERVK HERV3 HERVE HERV9NC HERVL74 HERV HERV35I
HERVK14C HERV1 HERV4 HERVK22 HERV30 HERVS71
HERVK11 HERV17 HERVIP10B3 HERVK14 HERVL18
HERVP71A HERVL32 HERVH48 HERVKC4 HERVI HERVK3
HERVK11D HERV15 HERVK9
```

这种，没有特别标准的HERVK/HERVH/HERVL……这种聚合（featureCounts用的是repeatmasker官网下载的gtf，我自己提取了与HERV相关的行，这里我用的stellarscope作者自己整理的gtf，会包含一些ltr以及一些看起来不像HERV的条目）


