---
layout: mypost
title: 使用我的GSE157827数据进行初步分析
category: other
subcategory: other-other
---

2025.12.31-2026.1.14研究进展

<!-- more -->

### try1

#### 构建Seurat对象

```r
library(Seurat)
library(Matrix)
library(tidyverse)
library(readxl)
# 读取计数矩阵
data_root <- "/public/home/GENE_proc/wth/GSE157827/mtx/"
read_one_srr <- function(srr) {
  gene_dir <- file.path(data_root, srr, "gene")
  herv_dir <- file.path(data_root, srr, "hERV")
  gene_counts <- ReadMtx(
    mtx = file.path(gene_dir, "counts.mtx"),
    features = file.path(gene_dir, "features.tsv"),
    cells = file.path(gene_dir, "barcodes.tsv")
  )
  herv_counts <- ReadMtx(
    mtx = file.path(herv_dir, "counts.mtx"),
    features = file.path(herv_dir, "features.tsv"),
    cells = file.path(herv_dir, "barcodes.tsv"),
    feature.column = 1
  )
  colnames(gene_counts) <- paste(srr, colnames(gene_counts), sep = "_")
  colnames(herv_counts) <- paste(srr, colnames(herv_counts), sep = "_")
  common_cells <- intersect(colnames(gene_counts), colnames(herv_counts))
  gene_counts <- gene_counts[, common_cells, drop = FALSE]
  herv_counts <- herv_counts[, common_cells, drop = FALSE]
  seu <- CreateSeuratObject(
    counts = gene_counts,
    assay = "RNA",
    project = "AD_hERV"
  )
  seu[["HERV"]] <- CreateAssayObject(counts = herv_counts)
  seu$SRR_id <- srr
  return(seu)
}
srr_ids <- list.dirs(data_root, full.names = FALSE, recursive = FALSE)
seu_list <- list()
for (srr in srr_ids) {
  seu <- read_one_srr(srr)
  if (!is.null(seu)) {
    seu_list[[srr]] <- seu
  }
}
seu <- Reduce(function(x, y) merge(x, y), seu_list)
rm(seu_list)
head(seu@meta.data)
# 添加metadata
meta_map <- read_xlsx("/public/home/GENE_proc/wth/GSE157827/raw_data/metadata/metadata.xlsx")
sample_info <- read_xlsx("/public/home/GENE_proc/wth/GSE157827/raw_data/metadata/sample_info.xlsx")
names(meta_map) <- make.names(names(meta_map))
names(sample_info) <- make.names(names(sample_info))
meta_map <- meta_map %>%
  select(individuals, SRR_id, sample_id, tissue)
colnames(meta_map) <- c("sample_id", "SRR_id", "GSM", "tissue")
metadata <- meta_map %>%
  left_join(sample_info, by = "sample_id")
cell_meta <- seu@meta.data %>%
  rownames_to_column("cell")
cell_meta2 <- cell_meta %>%
  left_join(metadata, by = "SRR_id")
sum(is.na(cell_meta2$sample_id))  # 检查是否有映射失败
new_cols <- setdiff(names(cell_meta2), names(seu@meta.data))
meta_to_add <- cell_meta2 %>%
  select(cell, all_of(new_cols)) %>%
  column_to_rownames("cell")
seu <- AddMetaData(seu, metadata = meta_to_add)
# 合并每个layers
seu <- JoinLayers(seu, assay = "RNA")
Layers(seu, assay = "RNA")  # 检查一下layers
# 线粒体/核糖体比例
seu <- PercentageFeatureSet(seu, pattern = "^MT-", col.name = "percent_mito")
seu <- PercentageFeatureSet(seu, pattern = "^RP[SL]", col.name = "percent_ribo")
# 保存数据
saveRDS(
  seu, 
  file = "/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827.rds", 
  compress = "xz"
)
```

```
> seu
An object of class Seurat 
93660 features across 304953 samples within 2 assays 
Active assay: RNA (78691 features, 0 variable features)
 1 layer present: counts
 1 other assay present: HERV
```

#### 质控

##### 看数据分布

```r
scRNA <- readRDS("/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827.rds")
res_dir <- "/public/home/GENE_proc/wth/GSE157827/res/"
scRNA$orig.ident <- scRNA$sample_id
scRNA$group <- factor(scRNA$diagnosis, levels = c("NC", "AD"))
# 基因数/UMI数
feats <- c("nFeature_RNA", "nCount_RNA")
p_filt_b_1 <- VlnPlot(
  scRNA, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_b_2 <- VlnPlot(
  scRNA, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# HERV数
feats <- c("nCount_HERV", "nFeature_HERV")
p_filt_b_3 <- VlnPlot(
  scRNA, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_b_4 <- VlnPlot(
  scRNA, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# HERV占整个转录本的比例
scRNA$HERV_fraction <- scRNA$nCount_HERV / (scRNA$nCount_HERV + scRNA$nCount_RNA)
p_filt_b_7 <- VlnPlot(
  scRNA, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "group"
) + NoLegend()
p_filt_b_8 <- VlnPlot(
  scRNA, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# 线粒体/核糖体比例
feats <- c("percent_mito", "percent_ribo")
p_filt_b_5 <- VlnPlot(
  scRNA, features = feats, 
  pt.size = 0, 
  ncol = 2,
  group.by = "group"  # 按AD/NC分组看分布
) + NoLegend()
p_filt_b_6 <- VlnPlot(
  scRNA, features = feats, 
  pt.size = 0, 
  ncol = 1,
  group.by = "orig.ident"  # 按样本看分布
) + NoLegend()
# 拼图展示
pdf(file.path(res_dir, "before_filter.pdf"), width = 20, height = 20)
p <- (p_filt_b_1 / p_filt_b_2) | (p_filt_b_3 / p_filt_b_4) | (p_filt_b_5 / p_filt_b_6) | (p_filt_b_7 / p_filt_b_8)
print(p)
dev.off()
```

![my_GSE157827_1](/upload/md-image/other/my_GSE157827_1.png){:width="800px" height="800px"}

```
> summary(scRNA$nFeature_RNA)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
     16     799    1203    1414    1854   10993 
> summary(scRNA$nCount_RNA)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    144    1099    1662    2239    2728   68430 
> summary(scRNA$nCount_HERV)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    5.00   11.00   14.07   19.00  223.00 
> summary(scRNA$nFeature_HERV)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    5.00    9.00   11.46   15.00  147.00 
> summary(scRNA$HERV_fraction)
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
0.000000 0.004047 0.006073 0.006409 0.008417 0.050000 
> summary(scRNA$percent_mito)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.382   3.100  10.467   8.076  99.093 
> summary(scRNA$percent_ribo)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.4058  0.5969  0.7382  0.8642 22.7354 
```

##### 确定过滤阈值

**细胞阈值**：

```r
# 过滤阈值
retained_c_umi_low <- scRNA$nFeature_RNA > 900
retained_c_umi_high <- scRNA$nFeature_RNA < 6000
retained_c_count_low  <- scRNA$nCount_RNA > 1200
retained_c_count_high <- scRNA$nCount_RNA < 30000
retained_c_mito <- scRNA$percent_mito < 10
retained_c_ribo <- scRNA$percent_ribo < 3
keep_cells <- retained_c_umi_low & retained_c_umi_high & retained_c_mito & retained_c_ribo
# 看看交集
df_fail <- data.frame(
  cell = Cells(scRNA),
  low_nFeature = !retained_c_umi_low,
  high_nFeature = !retained_c_umi_high,
  low_nCount = !retained_c_count_low,
  high_nCount = !retained_c_count_high,
  high_mito = !retained_c_mito,
  high_ribo = !retained_c_ribo
)
pdf(file.path(res_dir, "cell_filter_upset.pdf"), width = 12, height = 6)
ComplexUpset::upset(
  df_fail,
  intersect = c("low_nFeature","high_nFeature","low_nCount","high_nCount","high_mito","high_ribo"),
  base_annotations = list('Intersection size' = intersection_size())
)
dev.off()
```

![my_GSE157827_2](/upload/md-image/other/my_GSE157827_2.png){:width="800px" height="800px"}

**基因阈值**：

```r
scRNA_cells <- subset(scRNA, cells = Cells(scRNA)[keep_cells])
counts_rna <- GetAssayData(scRNA_cells, assay = "RNA", slot = "counts")
feature_rowsum <- Matrix::rowSums(counts_rna > 0)
retained_f_low <- feature_rowsum > ncol(scRNA_cells) * 0.005  # 只保留“至少在0.5%细胞里表达过”的基因
genes_keep <- names(feature_rowsum)[retained_f_low]
# rankplot辅助看阈值
rankplot <- data.frame(
  feature_count = sort(feature_rowsum),
  gene = names(sort(feature_rowsum)),
  Rank = seq_along(feature_rowsum)
)
library(ggbreak)
pdf(file.path(res_dir, "gene_filter.pdf"), width = 12, height = 8)
p_gene <- ggplot(rankplot, aes(x = Rank, y = feature_count)) +
  geom_point() +
  scale_y_break(c(10000, 100000)) +
  geom_hline(yintercept = ncol(scRNA_cells) * 0.005, color = "red") +
  geom_text(x = 10000, y = 4000, size = 5,
            label = "Feature cutoff : ncol(scRNA)*0.5%")
print(p_gene)
dev.off()
```

![my_GSE157827_3](/upload/md-image/other/my_GSE157827_3.png){:width="800px" height="800px"}

**hERV阈值**：

```r
counts_herv <- GetAssayData(scRNA_cells, assay = "HERV", slot = "counts")
herv_rowsum <- Matrix::rowSums(counts_herv > 0)
herv_keep <- names(herv_rowsum)[herv_rowsum > 50]  # 至少50个细胞中表达过
cat("HERV features before:", nrow(counts_herv), "\n")  # 14969
cat("HERV features kept:", length(herv_keep), "\n")  # 3351
rankplot_herv <- data.frame(
  feature_count = sort(herv_rowsum),
  feature = names(sort(herv_rowsum)),
  Rank = seq_along(herv_rowsum)
)
pdf(file.path(res_dir, "gene_filter_herv.pdf"), width = 10, height = 5)
ggplot(rankplot_herv, aes(x = Rank, y = feature_count)) +
  geom_point(size = 0.4) +
  geom_hline(yintercept = herv_cutoff, color = "red") +
  xlab("Rank") + ylab("Cells with counts>0 (per HERV feature)")
dev.off()
```

![my_GSE157827_4](/upload/md-image/other/my_GSE157827_4.png){:width="800px" height="800px"}

##### 过滤

```r
scRNA_cells[["RNA"]] <- subset(scRNA_cells[["RNA"]], features = genes_keep)
scRNA_cells[["HERV"]] <- subset(scRNA_cells[["HERV"]], features = herv_keep)
# 重新计算nCount和nFeature
rna_counts <- GetAssayData(scRNA_cells, assay = "RNA", slot = "counts")
scRNA_cells$nCount_RNA <- Matrix::colSums(rna_counts)
scRNA_cells$nFeature_RNA <- Matrix::colSums(rna_counts > 0)
herv_counts <- GetAssayData(scRNA_cells, assay = "HERV", slot = "counts")
scRNA_cells$nCount_HERV <- Matrix::colSums(herv_counts)
scRNA_cells$nFeature_HERV <- Matrix::colSums(herv_counts > 0)
scRNA_cells$HERV_fraction <- scRNA_cells$nCount_HERV / (scRNA_cells$nCount_HERV + scRNA_cells$nCount_RNA)
# 查看过滤后分布
# 基因数/UMI数
feats <- c("nFeature_RNA", "nCount_RNA")
p_filt_a_1 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_a_2 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# HERV数
feats <- c("nCount_HERV", "nFeature_HERV")
p_filt_a_3 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_a_4 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
p_filt_a_7 <- VlnPlot(
  scRNA_cells, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "group"
) + NoLegend()
p_filt_a_8 <- VlnPlot(
  scRNA_cells, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# 线粒体/核糖体比例
feats <- c("percent_mito", "percent_ribo")
p_filt_a_5 <- VlnPlot(
  scRNA_cells, features = feats, 
  pt.size = 0, 
  ncol = 2,
  group.by = "group"  # 按AD/NC分组看分布
) + NoLegend()
p_filt_a_6 <- VlnPlot(
  scRNA_cells, features = feats, 
  pt.size = 0, 
  ncol = 1,
  group.by = "orig.ident"  # 按样本看分布
) + NoLegend()
# 拼图展示
pdf(file.path(res_dir, "after_filter.pdf"), width = 20, height = 20)
p <- (p_filt_a_1 / p_filt_a_2) | (p_filt_a_3 / p_filt_a_4) | (p_filt_a_5 / p_filt_a_6) | (p_filt_a_7 / p_filt_a_8)
print(p)
dev.off()
# 保存数据
saveRDS(
    scRNA_cells, 
    file = "/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827_filt.rds", 
    compress = "xz"
)
```

![my_GSE157827_5](/upload/md-image/other/my_GSE157827_5.png){:width="800px" height="800px"}

```
> dim(scRNA_cells)
[1]  18217 189086
> table(scRNA_cells$group)
    NC     AD 
100788  88298 
> table(scRNA_cells$orig.ident)
  AD1  AD10  AD13  AD19   AD2  AD20  AD21   AD4   AD5   AD8   AD9  NC11  NC12 
 9802 19632  1128  4623 14677 11959  3708  3147 11639   592  7391   171 18635 
 NC14  NC15  NC16  NC17  NC18   NC3   NC7 
18437 13877   133 16229 14671  8078 10557 
```

可以看到似乎有的样本细胞数非常少，不过查看作者的计数矩阵，似乎也是有一些样本的细胞数很少。我的结果中AD8、NC11、NC16在作者的计数矩阵中也是属于比较少的一堆，而且我设置的阈值比作者的更严格，所以细胞数就更少了

```
> table(author_scRNA$orig.ident)
  NC3   NC7  NC11  NC12  NC14  NC15  NC16  NC17  NC18   AD1   AD2   AD4   AD5 
 6218  6372  1587 15568 10932  8385  4235 14263 11476  6173 15276  5980 12356 
  AD6   AD8   AD9  AD10  AD13  AD19  AD20  AD21 
  311  2405  9789 16013  1608  3614  9169  7786 
```

#### 与作者的计数矩阵对照

```r
library(Matrix)
seu_ours <- readRDS("/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827_filt.rds")
seu_auth <- readRDS("/public/home/GENE_proc/wth/GSE157827/data/GSE157827_filt.rds")
res_dir <- "/public/home/GENE_proc/wth/GSE157827/res/"
seu_ours$orig.ident <- seu_ours$sample_id
seu_ours$group <- factor(seu_ours$diagnosis, levels = c("NC", "AD"))
meta_ours <- seu_ours@meta.data %>%
  rownames_to_column("cell_ours")
meta_ours <- meta_ours %>%
  mutate(
    barcode = str_replace(cell_ours, "^.*_", ""),
    GSM = as.character(GSM),
    sample = as.character(orig.ident),
    cell_like_auth = paste0(GSM, "_", sample, "_", barcode, "-1"),
    cell_like_auth_no1 = str_replace(cell_like_auth, "-1$", "")
  )
auth_cells_raw <- colnames(seu_auth)
auth_cells_no1 <- str_replace(auth_cells_raw, "-1$", "")
our_ids_no1 <- meta_ours$cell_like_auth_no1
# 看看我的细胞和作者的细胞有多少是相同的
common_no1 <- intersect(our_ids_no1, auth_cells_no1)
cat("ours cells:", length(our_ids_no1), "\n")
cat("auth cells:", length(auth_cells_no1), "\n")
cat("common cells:", length(common_no1), "\n")
cat("overlap % (of ours):", round(length(common_no1)/length(our_ids_no1)*100, 2), "%\n")
cat("overlap % (of auth):", round(length(common_no1)/length(auth_cells_no1)*100, 2), "%\n")
```

很奇怪，这步的重叠率只有大概25%，即使我拿原始计数矩阵也只有大约30%

**在重叠的细胞上比较计数的一致性**：

```r
mat_ours <- GetAssayData(seu_ours, assay = "RNA", slot = "counts")
mat_auth <- GetAssayData(seu_auth, assay = "RNA", slot = "counts")
our_map <- setNames(meta_ours$cell_ours, meta_ours$cell_like_auth_no1)
our_cells_common <- unname(our_map[common_no1])
auth_map <- setNames(auth_cells_raw, auth_cells_no1)
auth_cells_common <- unname(auth_map[common_no1])
common_genes <- intersect(rownames(mat_ours), rownames(mat_auth))
mat_ours_sub <- mat_ours[common_genes, our_cells_common, drop = FALSE]
mat_auth_sub <- mat_auth[common_genes, auth_cells_common, drop = FALSE]
cat("common genes:", length(common_genes), "\n")
```

每个细胞的总UMI：

```r
our_lib  <- Matrix::colSums(mat_ours_sub)
auth_lib <- Matrix::colSums(mat_auth_sub)
cor_lib <- cor(log10(our_lib + 1), log10(auth_lib + 1))
cat("cell library size corr (log10+1):", cor_lib, "\n")  # 0.922925
pdf(file.path(res_dir, "author_our_umi.pdf"), width = 10, height = 10)
plot(log10(auth_lib + 1), log10(our_lib + 1),
     xlab = "author log10(lib+1)", ylab = "ours log10(lib+1)", pch = 16, cex = 0.4)
abline(0, 1, col = "red")
dev.off()
```

![my_GSE157827_6](/upload/md-image/other/my_GSE157827_6.png){:width="500px" height="500px"}

每个基因的总counts：

```r
our_gene_sum  <- Matrix::rowSums(mat_ours_sub)
auth_gene_sum <- Matrix::rowSums(mat_auth_sub)
cor_gene <- cor(log10(our_gene_sum + 1), log10(auth_gene_sum + 1))
cat("gene total counts corr (log10+1):", cor_gene, "\n")  # 0.7527359
pdf(file.path(res_dir, "author_our_counts.pdf"), width = 10, height = 10)
plot(log10(auth_gene_sum + 1), log10(our_gene_sum + 1),
     xlab = "author log10(geneSum+1)", ylab = "ours log10(geneSum+1)", pch = 16, cex = 0.4)
abline(0, 1, col = "red")
dev.off()
```

![my_GSE157827_7](/upload/md-image/other/my_GSE157827_7.png){:width="500px" height="500px"}

每个细胞的基因向量相关性（随机抽一些细胞）：

```r
set.seed(1)
k <- min(200, ncol(mat_ours_sub))
cells_pick <- sample(seq_len(ncol(mat_ours_sub)), k)
cors <- sapply(cells_pick, function(j){
  x <- as.numeric(mat_ours_sub[, j])
  y <- as.numeric(mat_auth_sub[, j])
  cor(log1p(x), log1p(y))
})
summary(cors)
pdf(file.path(res_dir, "author_our_corr.pdf"), width = 10, height = 10)
hist(cors, breaks = 30, main = "Per-cell cor(log1p counts)", xlab = "cor")
dev.off()
```

![my_GSE157827_8](/upload/md-image/other/my_GSE157827_8.png){:width="500px" height="500px"}

可以看到在重叠的细胞内，我的计数结果和作者的基本一致

---

为了看一看是什么原因导致细胞名不一致，我又按样本（GSM）分别看了重叠率，发现所有样本的重叠率都在20%-60%区间，没有说某几个样本完全重叠/不重叠的情况，说明barcode不匹配是发生在所有样本上的

询问了GPT，除了之前反复提过的STARsolo和cellranger计数上的区别，很有可能作者提供的计数矩阵和fastq数据不完全匹配——比如一个GSM对应多个SRR（技术重复/不同lane），我是计数了全部SRR，并且最后直接进行合并，作者可能只取了部分/合并时处理方式不同（比如过滤掉某些样本），这也可以解释为什么上面过滤时，我在第一次尝试时，虽然使用了和作者一样（甚至更严格）的阈值，但最后的细胞数却多了近1/3（24w-17w），后面才不得不逐渐提高阈值来让细胞数和作者的接近

为了验证这个想法，我按SRR分组计算重叠率，发现确实在SRR层面，重叠率差异很大，有些接近100%，有些只有30%-5%，这样的结果就很奇怪

之后我又看了“同一个GSM内，一个barcode会不会出现在多个SRR中”，结果发现很多barcode在GSM内出现次数都近似于该GSM包含的SRR数，就是说，这里的每个SRR是同一文库的lane拆分，而我在计数时把它们都当成独立run进行计数了

最后只能重跑一篇计数流程，把属于同一GSM的多个SRR当作多lane输入给STAR
- 不能直接把多个SRR的计数矩阵相加，因为UMI的去重是在计数阶段，直接相加会把跨lane的相同UMI叠加，产生系统性偏差

### try2

#### STAR计数

先做一个SRR->GSM的映射`srr2gsm.csv`

![my_GSE157827_9](/upload/md-image/other/my_GSE157827_9.png){:width="300px" height="300px"}

与上一版本的代码相比，除了先把SRR都映射到GSM上
- `--soloUMIlen 10`：作者的GSM说明里写的是`Chromium Single Cell 3′ Library Kit v3`，按理论来讲v3的UMI长度应该是12（官方pdf是这么说的），我之前写成了10，但实测改为12之后反而是错的
- `--soloFeatures Gene GeneFull`：打开pre-mRNA计数，后续都用GeneFull中的结果
- `--soloCellFilter EmptyDrops_CR`：让cell calling策略接近CellRanger（使用更像CellRanger的细胞筛选方法）

```sh
workDir=/public/home/GENE_proc/wth/GSE157827/
genomeDir=/public/home/wangtianhao/Desktop/STAR_ref/hg38/
fqDir=${workDir}/fastq
mapFile=${fqDir}/srr2gsm.csv
whitelist=/public/home/wangtianhao/Desktop/STAR_ref/whitelist/3M-february-2018.txt
hERV_gtf=/public/home/wangtianhao/Desktop/STAR_ref/transcripts.gtf
res_barcodes=barcodes
res_features=features
res_counts=counts
cd ${workDir}
module load miniconda3/base
dos2unix ${mapFile}
# 取所有GSM
GSM_LIST=$(cut -d',' -f2 "${mapFile}" | sort -u)
for GSM in ${GSM_LIST}; do
    GSM=${GSM//$'\r'/}
    echo "=============================="
    echo "[GSM] ${GSM}"
    SRR_LIST=$(awk -F',' -v g="${GSM}" '$2==g{print $1}' "${mapFile}")
    nSRR=$(echo "${SRR_LIST}" | wc -l | awk '{print $1}')
    echo "  SRR count: ${nSRR}"
    echo "${SRR_LIST}" | sed 's/^/  - /'
    cdna_files=$(echo "${SRR_LIST}" | sed "s|^|${fqDir}/|; s|$|_2.fastq.gz|" | paste -sd, -)
    bcumi_files=$(echo "${SRR_LIST}" | sed "s|^|${fqDir}/|; s|$|_1.fastq.gz|" | paste -sd, -)
    for f in $(echo "${cdna_files}" | tr ',' ' ') $(echo "${bcumi_files}" | tr ',' ' '); do
        if [[ ! -f "${f}" ]]; then
        echo "[ERROR] Missing fastq: ${f}" >&2
        exit 1
        fi
    done
    # STARsolo + stellarscope
    conda activate STAR
    mkdir -p star
    STAR \
        --runMode alignReads \
        --runThreadN 16 \
        --genomeDir ${genomeDir} \
        --readFilesIn ${cdna_files} ${bcumi_files} \
        --readFilesCommand zcat \
        --outFileNamePrefix star/${GSM} \
        --soloType CB_UMI_Simple \
        --soloCBstart 1 \
        --soloCBlen 16 \
        --soloUMIstart 17 \
        --soloUMIlen 10 \
        --soloBarcodeReadLength 0 \
        --soloCBwhitelist ${whitelist} \
        --soloFeatures Gene GeneFull \
        --clipAdapterType CellRanger4 \
        --soloCellFilter EmptyDrops_CR \
        --soloCBmatchWLtype 1MM_multi_Nbase_pseudocounts \
        --soloUMIfiltering MultiGeneUMI_CR \
        --soloUMIdedup 1MM_CR \
        --outSAMtype BAM SortedByCoordinate \
        --outSAMattributes NH HI nM AS CR UR CB UB GX GN sS sQ sM \
        --outSAMunmapped Within \
        --outFilterScoreMin 30 \
        --limitOutSJcollapsed 5000000 \
        --outFilterMultimapNmax 500 \
        --outFilterMultimapScoreRange 5
    conda deactivate
    conda activate stellarscope
    mkdir -p stellarscope/${GSM}
    mkdir -p tmp/${GSM}
    samtools view -@1 -u -F 4 \
        -D CB:<(tail -n+1 star/${GSM}Solo.out/GeneFull/filtered/barcodes.tsv) \
        star/${GSM}Aligned.sortedByCoord.out.bam \
        | samtools sort -@16 -n -t CB -T ./tmp/${GSM} \
        > stellarscope/${GSM}/Aligned.sortedByCB.bam
    stellarscope assign \
        --outdir stellarscope/${GSM} \
        --nproc 16 \
        --stranded_mode F \
        --whitelist star/${GSM}Solo.out/GeneFull/filtered/barcodes.tsv \
        --pooling_mode individual \
        --reassign_mode best_exclude \
        --max_iter 500 \
        --updated_sam \
        stellarscope/${GSM}/Aligned.sortedByCB.bam \
        ${hERV_gtf}
    conda deactivate
    mkdir -p mtx/${GSM}/gene
    cp star/${GSM}Solo.out/GeneFull/filtered/barcodes.tsv mtx/${GSM}/gene/${res_barcodes}.tsv
    cp star/${GSM}Solo.out/GeneFull/filtered/features.tsv mtx/${GSM}/gene/${res_features}.tsv
    cp star/${GSM}Solo.out/GeneFull/filtered/matrix.mtx mtx/${GSM}/gene/${res_counts}.mtx
    mkdir -p mtx/${GSM}/hERV
    cp stellarscope/${GSM}/stellarscope-barcodes.tsv mtx/${GSM}/hERV/${res_barcodes}.tsv
    cp stellarscope/${GSM}/stellarscope-features.tsv mtx/${GSM}/hERV/${res_features}.tsv
    cp stellarscope/${GSM}/stellarscope-TE_counts.mtx mtx/${GSM}/hERV/${res_counts}.mtx
done
rm -rf ./tmp
echo "[DONE] GSM-level counting finished."
du -sh ./mtx
```

#### 构建Seurat对象

唯一差别就是细胞命名，这里我直接和作者的对齐了

```r
library(Seurat)
library(Matrix)
library(tidyverse)
library(readxl)
data_root <- "/public/home/GENE_proc/wth/GSE157827/mtx/"
meta_file <- "/public/home/GENE_proc/wth/GSE157827/raw_data/metadata/metadata.xlsx"
sample_file <- "/public/home/GENE_proc/wth/GSE157827/raw_data/metadata/sample_info.xlsx"
# 读取metadata
meta_map <- read_xlsx(meta_file)
sample_info <- read_xlsx(sample_file)
names(meta_map) <- make.names(names(meta_map))
names(sample_info) <- make.names(names(sample_info))
gsm_meta <- meta_map %>%  # GSM级别信息
  transmute(
    GSM = as.character(sample_id),
    group = as.character(diagnosis),
    orig.ident = as.character(individuals),
    tissue = as.character(tissue)
  ) %>%
  distinct(GSM, .keep_all = TRUE)
donor_info <- sample_info %>%  # 样本信息
  mutate(orig.ident = as.character(sample_id)) %>%
  select(-sample_id)
gsm_info <- gsm_meta %>%  # 合并
  left_join(donor_info, by = "orig.ident")
# 检查有无NA
any(is.na(gsm_info$orig.ident))
sum(is.na(gsm_info[[names(donor_info)[1]]]))
nrow(gsm_info)
gsm2indv <- setNames(gsm_info$orig.ident, gsm_info$GSM)  # GSM -> orig.ident
# 读取计数矩阵
normalize_barcode <- function(x) {  # 如果已经有`-数字`后缀（比如`-1`）就保留，否则补`-1`
  ifelse(grepl("-\\d+$", x), x, paste0(x, "-1"))
}
read_one_gsm <- function(gsm, gsm_info, data_root) {
  gene_dir <- file.path(data_root, gsm, "gene")
  herv_dir <- file.path(data_root, gsm, "hERV")
  # 读取矩阵
  gene_counts <- ReadMtx(
    mtx = file.path(gene_dir, "counts.mtx"),
    features = file.path(gene_dir, "features.tsv"),
    cells = file.path(gene_dir, "barcodes.tsv"),
    unique.features = TRUE
  )
  herv_counts <- ReadMtx(
    mtx = file.path(herv_dir, "counts.mtx"),
    features = file.path(herv_dir, "features.tsv"),
    cells = file.path(herv_dir, "barcodes.tsv"),
    feature.column = 1,
    unique.features = TRUE
  )
  # 取该GSM的样本信息
  info <- gsm_info %>% filter(GSM == gsm)
  indv <- info$orig.ident
  # 生成作者风格cellname：GSM_individuals_barcode-1
  gene_bc <- normalize_barcode(colnames(gene_counts))
  herv_bc <- normalize_barcode(colnames(herv_counts))
  colnames(gene_counts) <- paste(gsm, indv, gene_bc, sep = "_")
  colnames(herv_counts) <- paste(gsm, indv, herv_bc, sep = "_")
  # 对齐两套assay的细胞集合
  common_cells <- intersect(colnames(gene_counts), colnames(herv_counts))
  gene_counts <- gene_counts[, common_cells, drop = FALSE]
  herv_counts <- herv_counts[, common_cells, drop = FALSE]
  # 构建Seurat对象
  seu <- CreateSeuratObject(
    counts = gene_counts,
    assay = "RNA",
    project = "GSE157827"
  )
  seu[["HERV"]] <- CreateAssayObject(counts = herv_counts)
  # 添加metadata
  seu$GSM <- gsm
  seu$orig.ident <- indv
  seu$group <- info$group
  seu$tissue <- info$tissue
  extra_cols <- setdiff(colnames(info), c("GSM", "group", "orig.ident", "tissue"))
  for (cc in extra_cols) {
    seu[[cc]] <- info[[cc]][1]
  }
  return(seu)
}
gsm_ids <- list.dirs(data_root, full.names = FALSE, recursive = FALSE)
seu_list <- list()
for (gsm in gsm_ids) {
  tmp <- read_one_gsm(gsm, gsm_info = gsm_info, data_root = data_root)
  if (!is.null(tmp)) {
    seu_list[[gsm]] <- tmp
  }
}
seu <- Reduce(function(x, y) merge(x, y), seu_list)
rm(seu_list)
# 合并每个layers
seu <- JoinLayers(seu, assay = "RNA")
Layers(seu, assay = "RNA")  # 检查一下layers
# 线粒体/核糖体比例
seu <- PercentageFeatureSet(seu, pattern = "^MT-", col.name = "percent_mito")
seu <- PercentageFeatureSet(seu, pattern = "^RP[SL]", col.name = "percent_ribo")
seu$HERV_fraction <- seu$nCount_HERV / (seu$nCount_HERV + seu$nCount_RNA)
# 查看结果情况
seu
head(seu@meta.data)
table(seu$orig.ident)
table(seu$GSM)
seu$group <- factor(seu$group, levels = c("NC", "AD"))
# 保存数据
saveRDS(
  seu, 
  file = "/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827.rds", 
  compress = "xz"
)
```

```
> seu
An object of class Seurat 
93660 features across 181653 samples within 2 assays 
Active assay: RNA (78691 features, 0 variable features)
 1 layer present: counts
 1 other assay present: HERV
> table(seu$orig.ident)
  AD1  AD10  AD13  AD19   AD2  AD20  AD21   AD4   AD5   AD6   AD8   AD9  NC11  NC12  NC14  NC15  NC16 
 6165 16437  1841  3898 15607  9430  8736  5895 12623  3204  2679 10269  3560 15727 10951  8492  6899 
 NC17  NC18   NC3   NC7 
14572 11821  6439  6408 
```

#### 质控

**过滤前**

```r
seu <- readRDS("/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827.rds")
feats <- c("nFeature_RNA", "nCount_RNA")
p_filt_b_1 <- VlnPlot(
  seu, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_b_2 <- VlnPlot(
  seu, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
feats <- c("percent_mito", "percent_ribo")
p_filt_b_3 <- VlnPlot(
  seu, features = feats, 
  pt.size = 0, 
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_b_4 <- VlnPlot(
  seu, features = feats, 
  pt.size = 0, 
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
pdf(file.path(res_dir, "before_filter.pdf"))
p <- (p_filt_b_1 / p_filt_b_2) | (p_filt_b_3 / p_filt_b_4)
print(p)
dev.off()
```

```
> fivenum(seu@meta.data$nFeature_RNA)
[1]    38   948  1618  2783 14543
> fivenum(seu@meta.data$nCount_RNA)
[1]    450   1367   2697   5627 118970
> fivenum(seu@meta.data$nCount_HERV)
[1]   0   3   8  16 375
> fivenum(seu@meta.data$nFeature_HERV)
[1]   0   3   6  13 191
> fivenum(seu@meta.data$HERV_fraction)
[1] 0.000000000 0.001904762 0.002690704 0.003473227 0.022727273
> fivenum(seu@meta.data$percent_mito)
[1]  0.0000000  0.4662729  1.0680017  2.6499303 96.6913580
> fivenum(seu@meta.data$percent_ribo)
[1]  0.0000000  0.2367424  0.3400397  0.5042546 15.1050420
```

![my_GSE157827_10](/upload/md-image/other/my_GSE157827_10.png){:width="600px" height="600px"}

**设置阈值**

```r
# 细胞阈值
retained_c_umi_low <- seu$nFeature_RNA > 500
retained_c_umi_high <- seu$nFeature_RNA < 8000
retained_c_count_low  <- seu$nCount_RNA > 1000
retained_c_count_high <- seu$nCount_RNA < 40000
retained_c_mito <- seu$percent_mito < 14
retained_c_ribo <- seu$percent_ribo < 3
keep_cells <- retained_c_mito & retained_c_ribo & retained_c_umi_low & retained_c_umi_high
scRNA_cells <- subset(seu, cells = Cells(seu)[keep_cells])
counts_rna <- GetAssayData(scRNA_cells, assay = "RNA", slot = "counts")
feature_rowsum <- Matrix::rowSums(counts_rna > 0)
# 基因阈值
retained_f_low <- feature_rowsum > ncol(scRNA_cells) * 0.005
genes_keep <- names(feature_rowsum)[retained_f_low]
counts_herv <- GetAssayData(scRNA_cells, assay = "HERV", slot = "counts")
herv_rowsum <- Matrix::rowSums(counts_herv > 0)
# hERV位点阈值
herv_cutoff <- ceiling(ncol(scRNA_cells) * 0.0001)
herv_keep <- names(herv_rowsum)[herv_rowsum > herv_cutoff]
cat("HERV features before:", nrow(counts_herv), "\n")  # 14969
cat("HERV features kept:", length(herv_keep), "\n")  # 4326
```

![my_GSE157827_11](/upload/md-image/other/my_GSE157827_11.png){:width="800px" height="800px"}

**过滤**

```r
scRNA_cells[["RNA"]] <- subset(scRNA_cells[["RNA"]], features = genes_keep)
scRNA_cells[["HERV"]] <- subset(scRNA_cells[["HERV"]], features = herv_keep)
scRNA_cells
table(scRNA_cells$group)
table(scRNA_cells$orig.ident)
rna_counts <- GetAssayData(scRNA_cells, assay = "RNA", slot = "counts")
scRNA_cells$nCount_RNA <- Matrix::colSums(rna_counts)
scRNA_cells$nFeature_RNA <- Matrix::colSums(rna_counts > 0)
herv_counts <- GetAssayData(scRNA_cells, assay = "HERV", slot = "counts")
scRNA_cells$nCount_HERV <- Matrix::colSums(herv_counts)
scRNA_cells$nFeature_HERV <- Matrix::colSums(herv_counts > 0)
scRNA_cells$HERV_fraction <- scRNA_cells$nCount_HERV / (scRNA_cells$nCount_HERV + scRNA_cells$nCount_RNA)
```

**过滤后结果**

```r
feats <- c("nFeature_RNA", "nCount_RNA")
p_filt_a_1 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_a_2 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
# HERV?
feats <- c("nCount_HERV", "nFeature_HERV")
p_filt_a_3 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_a_4 <- VlnPlot(
  scRNA_cells, features = feats,
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
p_filt_a_7 <- VlnPlot(
  scRNA_cells, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "group"
) + NoLegend()
p_filt_a_8 <- VlnPlot(
  scRNA_cells, features = "HERV_fraction",
  pt.size = 0,
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
feats <- c("percent_mito", "percent_ribo")
p_filt_a_5 <- VlnPlot(
  scRNA_cells, features = feats, 
  pt.size = 0, 
  ncol = 2,
  group.by = "group"
) + NoLegend()
p_filt_a_6 <- VlnPlot(
  scRNA_cells, features = feats, 
  pt.size = 0, 
  ncol = 1,
  group.by = "orig.ident"
) + NoLegend()
pdf(file.path(res_dir, "after_filter.pdf"), width = 20, height = 20)
p <- (p_filt_a_1 / p_filt_a_2) | (p_filt_a_3 / p_filt_a_4) | (p_filt_a_5 / p_filt_a_6) | (p_filt_a_7 / p_filt_a_8)
print(p)
dev.off()
```

最终结果：

```
> dim(scRNA_cells)  # 不包括hERV
[1]  21002 164219 
> table(scRNA_cells$GSM)
GSM4775561 GSM4775562 GSM4775563 GSM4775564 GSM4775565 GSM4775566 GSM4775567 GSM4775568 GSM4775569 
      5865      15080       5435      12140        230       2167       9238      15703       1517 
GSM4775570 GSM4775571 GSM4775572 GSM4775573 GSM4775574 GSM4775575 GSM4775576 GSM4775577 GSM4775578 
      3549       9037       7691       6056       6130       1520      15185      10596       8175 
GSM4775579 GSM4775580 GSM4775581 
      3554      13900      11451 
```

作者的计数矩阵过滤后：

```
> dim(scRNA_filt)
[1]  17276 169516
> table(scRNA_filt$orig.ident)
GSM4775561 GSM4775562 GSM4775563 GSM4775564 GSM4775565 GSM4775566 GSM4775567 GSM4775568 GSM4775569 
      6173      15276       5980      12356        311       2405       9789      16013       1608 
GSM4775570 GSM4775571 GSM4775572 GSM4775573 GSM4775574 GSM4775575 GSM4775576 GSM4775577 GSM4775578 
      3614       9169       7786       6218       6372       1587      15568      10932       8385 
GSM4775579 GSM4775580 GSM4775581 
      4235      14263      11476 
```

#### 与作者的计数矩阵对照

```r
seu_auth <- readRDS("/public/home/GENE_proc/wth/GSE157827/raw_data/GSE157827_filt.rds")
seu_ours <- readRDS("/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827_filt.rds")
res_dir <- "/public/home/GENE_proc/wth/GSE157827/res/"
auth_cells <- colnames(seu_auth)
our_cells <- colnames(seu_ours)
common_cells <- intersect(auth_cells, our_cells)
mat_ours <- GetAssayData(seu_ours, assay = "RNA", slot = "counts")
mat_auth <- GetAssayData(seu_auth, assay = "RNA", slot = "counts")
common_genes <- intersect(rownames(mat_ours), rownames(mat_auth))
```

```
> cat("ours cells:", length(our_cells), "\n")
ours cells: 164219 
> cat("auth cells:", length(auth_cells), "\n")
auth cells: 169516 
> cat("common cells:", length(common_cells), "\n")
common cells: 161921 
> cat("overlap % (of ours):", round(length(common_cells)/length(our_cells)*100, 2), "%\n")
overlap % (of ours): 98.6 %
> cat("overlap % (of auth):", round(length(common_cells)/length(auth_cells)*100, 2), "%\n")
overlap % (of auth): 95.52 %
> cat("ours genes:", length(rownames(mat_ours)), "\n")
ours genes: 21002 
> cat("auth genes:", length(rownames(mat_auth)), "\n")
auth genes: 17276 
> cat("common genes:", length(common_genes), "\n")
common genes: 13938 
> cat("overlap % (of ours):", round(length(common_genes)/length(rownames(mat_ours))*100, 2), "%\n")
overlap % (of ours): 66.37 %
> cat("overlap % (of auth):", round(length(common_genes)/length(rownames(mat_auth))*100, 2), "%\n")
overlap % (of auth): 80.68 %
```

**在重叠的细胞上比较计数的一致性**：

每个细胞的总UMI：

```r
mat_ours_sub <- mat_ours[common_genes, common_cells, drop = FALSE]
mat_auth_sub <- mat_auth[common_genes, common_cells, drop = FALSE]
our_lib  <- Matrix::colSums(mat_ours_sub)
auth_lib <- Matrix::colSums(mat_auth_sub)
cor_lib <- cor(log10(our_lib + 1), log10(auth_lib + 1))
cat("cell library size corr (log10+1):", cor_lib, "\n")  # 0.9997134
pdf(file.path(res_dir, "author_our_umi.pdf"), width = 10, height = 10)
plot(log10(auth_lib + 1), log10(our_lib + 1),
     xlab = "author log10(lib+1)", ylab = "ours log10(lib+1)", pch = 16, cex = 0.4)
abline(0, 1, col = "red")
dev.off()
```

![my_GSE157827_12](/upload/md-image/other/my_GSE157827_12.png){:width="500px" height="500px"}

每个基因的总counts：

```r
our_gene_sum  <- Matrix::rowSums(mat_ours_sub)
auth_gene_sum <- Matrix::rowSums(mat_auth_sub)
cor_gene <- cor(log10(our_gene_sum + 1), log10(auth_gene_sum + 1))
cat("gene total counts corr (log10+1):", cor_gene, "\n")  # 0.9746644
pdf(file.path(res_dir, "author_our_counts.pdf"), width = 10, height = 10)
plot(log10(auth_gene_sum + 1), log10(our_gene_sum + 1),
     xlab = "author log10(geneSum+1)", ylab = "ours log10(geneSum+1)", pch = 16, cex = 0.4)
abline(0, 1, col = "red")
dev.off()
```

![my_GSE157827_13](/upload/md-image/other/my_GSE157827_13.png){:width="500px" height="500px"}

每个细胞的基因向量相关性（随机抽3k细胞×3k基因）：

```r
set.seed(1)
v_my <- as.vector(log1p(mat_ours_sub))
v_auth <- as.vector(log1p(mat_auth_sub))
cells_sample <- sample(colnames(mat_ours_sub), 3000)
genes_sample <- sample(rownames(mat_ours_sub), 3000)
my_sub <- as.matrix(mat_ours_sub[genes_sample, cells_sample])
auth_sub <- as.matrix(mat_auth_sub[genes_sample, cells_sample])
v_my_sub <- as.vector(log1p(my_sub))
v_auth_sub <- as.vector(log1p(auth_sub))
cor_flat <- cor(v_my_sub, v_auth_sub)
cor_flat  # 0.9677604
pdf(file.path(res_dir, "author_our_corr.pdf"), width = 10, height = 10)
par(pin = c(10, 10))
plot(v_my_sub, v_auth_sub, pch = ".", xlab = "log1p(my)", ylab = "log1p(author)")
abline(0, 1, col = "red")
dev.off()
```

![my_GSE157827_14](/upload/md-image/other/my_GSE157827_14.png){:width="500px" height="500px"}

---

**抽取一部分细胞到本地**

```r
scRNA_cells <- readRDS("/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827_filt.rds")
set.seed(20260102)
prop_keep <- 1/3
cells_keep <- scRNA_cells@meta.data %>%
  rownames_to_column("cell") %>%
  group_by(orig.ident) %>%
  slice_sample(prop = prop_keep) %>%
  pull(cell)
scRNA_smaller <- subset(scRNA_cells, cells = cells_keep)
saveRDS(
    scRNA_smaller, 
    file = "/public/home/GENE_proc/wth/GSE157827/my_data/GSE157827_filt_smaller.rds", 
    compress = "xz"
)
```

```
> ncol(scRNA_smaller)
[1] 54731
> table(scRNA_smaller$group)
   NC    AD 
25519 29212 
> table(scRNA_smaller$orig.ident)
 AD1 AD10 AD13 AD19  AD2 AD20 AD21  AD4  AD5  AD6  AD8  AD9 NC11 NC12 NC14 NC15 NC16 NC17 NC18  NC3 
1955 5234  505 1183 5026 3012 2563 1811 4046   76  722 3079  506 5061 3532 2725 1184 4633 3817 2018 
 NC7 
2043 
```

#### 数据预处理





### 细胞轨迹test

#### 简介

以“Monocle3/Slingshot/tradeSeq”这三种工具为例

**简单来说**：
- Monocle3：想把细胞排序（例如构建pseudotime），并得到分支/主干结构。适合发育/分化、免疫激活连续谱、应激/反应性渐变等情况
- Slingshot：已经有Seurat聚类（UMAP/PCA），只想在这个结构上找主线/分支。适合亚群内连续谱（而不是“从零建图”）
- tradeSeq：给定pseudotime（来自Monocle/Slingshot等），对每个基因拟合GAM平滑曲线，然后做统计检验，回答“表达随状态轴如何变化、组间曲线是否不同”的问题，即“把轨迹变成可检验的差异结论”
  
  所以，Monocle3和Slingshot是上游分析，tradeSeq是下游分析

**Monocle3**：降维 → learn_graph → order_cells → pseudotime
- 轨迹骨架(principal graph)：不是简单连cluster，而是试图在低维空间里学出一条“主干+分支”的结构
- pseudotime：每个细胞在骨架上的位置，只代表“顺序/相对位置”，不等价真实时间，需要root（起点）
- 分支/分区(partition/branch)：把结构分成若干区域，分支点附近常有“状态转换”意义，每个分支不一定是“真实生物学分化”，有时是UMAP/图学习导致的结构
- 相比Slingshot，如果想要得到骨架图（像发育谱系那样），或者认为之前得到的聚类不完全准确、不想完全依赖聚类拓扑，就使用Monocle3

**Slingshot**：低维坐标（PCA/UMAP）+ cluster标签 → 在聚类间构建连接结构 → 在细胞层面拟合principal curves得到轨迹
- 路径(Lineage)：在“从起点cluster出发”的拓扑下，存在多个可能终点/分支路径
- pseudotime矩阵(pt_mat)：cells × lineages，每个细胞在每条lineage上都有一个pseudotime，如果不属于该路径就是NA
  
  一个细胞可能只属于某一条路径，也可能在分支附近对多条路径都有一定归属
- cellWeights矩阵(cw_mat)：cells × lineages，这个细胞对某条lineage的归属程度/权重，分支点附近的细胞可能对两条lineage都有权重
- 相比Monocle3，如果已经有准确聚类，且“状态谱”更多是聚类的连续过渡，希望轨迹推断对聚类结构更稳健，就使用Slingshot

**tradeSeq**：
- 输入：
  - 原始计数矩阵
  - pseudotime：来自Monocle/Slingshot等
  - cellWeights：存在分支、有多条路径时很重要
  - conditions：如AD/NC，用来比较曲线
- 输出：拟合模型对象gam——每个基因都有一条（或多条lineage × condition的）平滑表达曲线模型
- 常用检验：
  - `associationTest(gam)`：这个基因是否随pseudotime变化，适合找“状态轴上的标志基因/动态基因”
  - `conditionTest(gam)`：AD-NC的曲线形状/水平是否不同，组间在轨迹上是否不同步/不同形态
  - `startVsEndTest(gam)`：起点与终点是否显著不同，体现稳态与反应态的差异
  - `earlyDETest(gam)`：两组在轨迹早期就分开了吗（“早期偏移”）
  - `diffEndTest(gam)`：不同分支终点的表达是否不同（分支终末态比较）

**总结**：
- Monocle3：在该细胞类型内部学习到一条（或多条分支的）连续状态轨迹；伪时间刻画了从稳态向反应/应激态的连续过渡
- Slingshot：基于聚类拓扑与低维嵌入，拟合得到若干条潜在状态路径；细胞在主路径上的伪时间可用于描述状态推进，并用于下游动态分析
- tradeSeq：沿伪时间拟合表达平滑曲线，识别出显著随轨迹变化的基因，以及在AD与NC间轨迹动态显著不同的基因/模块，提示疾病改变了同一状态轴上的转变过程

---

**以astro细胞为例，直接使用之前已完成预处理的Seurat对象**

#### Monocle3的pseudotime

**数据准备**

```r
library(Seurat)
library(tidyverse)
library(patchwork)
scRNA <- readRDS("C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\data\\GSE157827_astro.rds")
res_dir <- "C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\res"
```

**pseudotime分析**

```r
library(monocle3)
expr <- GetAssayData(scRNA, slot = "counts")
cell_meta <- scRNA@meta.data
gene_meta <- data.frame(
  gene_short_name = rownames(expr), 
  row.names = rownames(expr)
)
cds <- new_cell_data_set(
  expr,
  cell_metadata = cell_meta,
  gene_metadata = gene_meta
)
# 直接使用Seurat的UMAP结果
reducedDims(cds)$UMAP <- Embeddings(scRNA, "umap")
cds <- cluster_cells(cds, reduction_method = "UMAP")
# 学习轨迹图
cds <- learn_graph(cds, use_partition = TRUE)
# try1：用braak.tangle.stage最小的细胞当root
earliest <- min(scRNA$braak.tangle.stage, na.rm = TRUE)
root_cells <- colnames(scRNA)[which(scRNA$braak.tangle.stage == earliest)]
# 排序
cds <- order_cells(cds, root_cells = root_cells)
pt <- monocle3::pseudotime(cds)
# 写回Seurat
scRNA$pseudotime <- pt[colnames(scRNA)]
```

```r
# 轨迹与分组分布
FeaturePlot(scRNA, features = "pseudotime")  # 看轨迹轴在UMAP上的走向
VlnPlot(scRNA, features = "pseudotime", group.by = "group", pt.size = 0)
VlnPlot(scRNA, features = "pseudotime", group.by = "braak.tangle.stage", pt.size = 0)
```

![细胞轨迹test1](/upload/md-image/other/细胞轨迹test1.png){:width="600px" height="600px"}

似乎不是“整张UMAP从一端平滑过渡到另一端”的那种形态，大部分都接近0，只有小部分有颜色

![细胞轨迹test2](/upload/md-image/other/细胞轨迹test2.png){:width="600px" height="600px"}

与上张图分布相似，两组都大量堆在接近0的位置，只有少量细胞在1–2.5的尾部，说明pseudotime的“有效动态范围”只覆盖了一小部分细胞，所以组间整体差异不容易被拉开

![细胞轨迹test3](/upload/md-image/other/细胞轨迹test3.png){:width="600px" height="600px"}

stage也都是大量细胞集中在低pseudotime，且stage之间没有非常清晰的“随分期单调递增”的趋势，说明当前这条pseudotime轴与Braak分期的对齐程度不强，不能得出“AD一定更反应/更晚期”的结论
- 提示root可能选的过宽（我在6000细胞中选择600个分期最早的作为root），导致pseudotime本身就不太像“单一方向的进程”
- Braak是样本级标签+分期不一定覆盖连续状态+样本间异质性大，导致不构成稳定梯度

```r
# 单基因平滑曲线
genes <- c("SLC1A2","ALDH1L1","GFAP")
df <- FetchData(scRNA, vars = c("pseudotime","group", genes))
df_long <- pivot_longer(df, cols = all_of(genes), names_to = "gene", values_to = "expr")
ggplot(df_long, aes(x = pseudotime, y = expr, color = group)) +
  geom_point(size = 0.2, alpha = 0.2) +
  geom_smooth(se = FALSE, method = "loess", span = 0.3) +
  facet_wrap(~gene, scales = "free_y") +
  theme_classic()
```

![细胞轨迹test4](/upload/md-image/other/细胞轨迹test4.png){:width="600px" height="600px"}

GFAP逐渐上升、SLC1A2较平（理论上应该下降）、ALDH1L1逐渐上升（确实是表达增强，但可能受技术因素影响），说明pseudotime与astro某些状态变化有关

可能的原因：用earliest分期的大量细胞当root，导致root覆盖太广，所以绝大多数细胞的pseudotime接近0，只有离这些root都远的一部分区域出现高pseudotime

---

考虑到之前的分析中，我们在差异基因中选了最top的一些计算了模块分数，能不能用这个模块分数来辅助选root

```r
# 用之前得到的划分好up/down的astro
scRNA_astro_sub <- readRDS("C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\data\\GSE157827_astro_sub.rds")
scRNA_astro_sub$subpop <- factor(scRNA_astro_sub$subpop, levels = c("Down","Up"))
marker_Astro <- FindMarkers(
  scRNA_astro_sub, 
  group.by = "subpop",
  ident.1 = "Down", 
  ident.2 = "Up"
)
marker_Astro <- marker_Astro[order(marker_Astro$p_val_adj, decreasing = F), ]
marker_Astro_sig <- marker_Astro %>%
  rownames_to_column("gene") %>%
  filter(p_val_adj < 0.05, abs(avg_log2FC) >= 0.25) %>% 
  filter(pct.1 >= 0.1 | pct.2 >= 0.1) %>% 
  filter(!grepl("^(AC|AL|LINC|AP|MT-)[0-9]", gene))
# Down子群体更高表达的基因
astro_down <- marker_Astro_sig %>%
  filter(avg_log2FC > 0) %>%
  arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
  slice_head(n = 20) %>%
  pull(gene)
# Up子群体更高表达的基因
astro_up <- marker_Astro_sig %>%
  filter(avg_log2FC < 0) %>%
  arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
  slice_head(n = 20) %>%
  pull(gene)
scRNA <- AddModuleScore(scRNA, features = list(astro_up), name = "ADup")
scRNA <- AddModuleScore(scRNA, features = list(astro_down), name = "ADdown")
FeaturePlot(scRNA, features = c("ADup1","ADdown1"))
VlnPlot(scRNA, features = c("ADup1","ADdown1"), group.by="group", pt.size=0)
```

![细胞轨迹test5](/upload/md-image/other/细胞轨迹test5.png){:width="600px" height="600px"}

![细胞轨迹test6](/upload/md-image/other/细胞轨迹test6.png){:width="600px" height="600px"}

在ADup和ADdown的层面，确实是形成了“状态区域”，也证明astro里确实存在“疾病相关表达程序”的整体偏移，提示可以使用up/down的模块分数来选root

---

**try2：使用模块分数选出稳态端当root**

- 稳态端：ADup1低+ADdown1高
- 反应端：ADup1高+ADdown1低

```r
root_score <- scale(scRNA$ADdown1) - scale(scRNA$ADup1)
names(root_score) <- colnames(scRNA)
# 在earliest分期中
scRNA$braak_num <- suppressWarnings(as.numeric(as.character(scRNA$braak.tangle.stage)))
earliest <- min(scRNA$braak_num, na.rm = TRUE)
cand <- colnames(scRNA)[scRNA$braak_num == earliest]
# 取最稳态的前200个
cand <- cand[order(root_score[cand], decreasing = TRUE)]
root_cells <- head(cand, 200)
# 只要一条主轴
cds <- learn_graph(cds, use_partition = FALSE)
cds <- order_cells(cds, root_cells = root_cells)
scRNA$pseudotime <- monocle3::pseudotime(cds)[colnames(scRNA)]
# 画图代码同上
```

![细胞轨迹test7](/upload/md-image/other/细胞轨迹test7.png){:width="800px" height="800px"}

![细胞轨迹test8](/upload/md-image/other/细胞轨迹test8.png){:width="600px" height="600px"}

- 可以看到，umap图上变蓝的部分更多，AD-NC的pseudotime差异也更明显（AD更富集在“后段状态”），同时braak分期更晚的pseudotime更高（说明这条轴与braak有一定相关性）
- SLC1A2随pseudotime变化不明显，GFAP后端状态与预期不符，可能是pseudotime高的细胞数在AD/NC不均衡，导致曲线在尾部容易被少量点带偏

想看一下“模块分数随pseudotime的趋势”

```r
df <- FetchData(obj, vars = c("pseudotime", "group", "ADup1", "ADdown1")) %>%
  filter(!is.na(pseudotime))
df_long <- df %>%
  pivot_longer(cols = c("ADup1", "ADdown1"), names_to = "module", values_to = "score")
# 相关系数
cor.test(df$pseudotime, df$ADup1, method = "spearman")  # 总体相关
cor.test(df$pseudotime, df$ADdown1, method = "spearman")
df %>% group_by(group) %>%  # 分组相关
  summarise(
    rho_ADup   = cor(pseudotime, ADup1, method = "spearman"),
    rho_ADdown = cor(pseudotime, ADdown1, method = "spearman"),
    .groups = "drop"
  )
# LOESS平滑曲线
ggplot(df_long, aes(x = pseudotime, y = score, color = group)) +
  geom_point(size = 0.2, alpha = 0.12) +
  geom_smooth(se = FALSE, method = "loess", span = 0.35) +
  facet_wrap(~module, scales = "free_y") +
  theme_classic()
# 分箱均值曲线（避免尾部LOESS被少量点带偏）
df_long <- df_long %>%
  mutate(pt_bin = ggplot2::cut_number(pseudotime, n = 30))
sum_tab <- df_long %>%
  group_by(group, module, pt_bin) %>%
  summarise(
    pt_mid = mean(pseudotime),
    score_mean = mean(score),
    n = dplyr::n(),
    .groups = "drop"
  )
ggplot(sum_tab, aes(x = pt_mid, y = score_mean, color = group)) +
  geom_line() +
  geom_point(aes(size = n), alpha = 0.8) +
  facet_wrap(~module, scales = "free_y") +
  theme_classic() +
  guides(size = "none")
```

```
data:  df$pseudotime and df$ADup1
S = 3.3663e+10, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.2405992 

data:  df$pseudotime and df$ADdown1
S = 5.5218e+10, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
       rho 
-0.2456553 

group  rho_ADup  rho_ADdown
NC	0.07784422	-0.2370371	
AD	0.33427566	-0.1747888	
```

![细胞轨迹test9](/upload/md-image/other/细胞轨迹test9.png){:width="800px" height="800px"}

- ADdown1：NC全程都高于AD，并随pseudotime整体缓慢下降（ADdown基因集作为稳态/保护/对照端程序，在“后段状态”逐渐变弱
- ADup1：AD在pseudotime后段明显上升，且上升幅度较NC更大（ADup基因集在“后段状态”增强，而且主要发生在AD细胞里）
- 相关系数的方向符合预期，rho值小说明“有信号但不是一条单因素决定的轴”（在AD这种复杂疾病状态谱里很正常）
- 分组相关系数说明这条pseudotime轴更能捕捉“AD中出现的反应/疾病相关程序的进行”

#### Slingshot+tradeSeq

**数据准备**：读取之前的Seurat对象并添加ADup和ADdown分数

```r
library(Seurat)
library(tidyverse)
library(patchwork)
library(SingleCellExperiment)
library(slingshot)
library(tradeSeq)
library(scater)
res_dir <- "C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\res"
sceu <- readRDS("C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\data\\GSE157827_astro.rds")
sceu_astro_sub <- readRDS("C:\\Users\\17185\\Desktop\\hERV_calc\\GSE157827\\data\\GSE157827_astro_sub.rds")
sceu_astro_sub$subpop <- factor(sceu_astro_sub$subpop, levels = c("Down","Up"))
marker_Astro <- FindMarkers(
  sceu_astro_sub, 
  group.by = "subpop",
  ident.1 = "Down", 
  ident.2 = "Up"
)
marker_Astro <- marker_Astro[order(marker_Astro$p_val_adj, decreasing = F), ]
marker_Astro_sig <- marker_Astro %>%
  rownames_to_column("gene") %>%
  filter(p_val_adj < 0.05, abs(avg_log2FC) >= 0.25) %>% 
  filter(pct.1 >= 0.1 | pct.2 >= 0.1) %>% 
  filter(!grepl("^(AC|AL|LINC|AP|MT-)[0-9]", gene))
astro_down <- marker_Astro_sig %>%
  filter(avg_log2FC > 0) %>%
  arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
  slice_head(n = 20) %>%
  pull(gene)
astro_up <- marker_Astro_sig %>%
  filter(avg_log2FC < 0) %>%
  arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
  slice_head(n = 20) %>%
  pull(gene)
sceu <- AddModuleScore(sceu, features = list(astro_up), name = "ADup")
sceu <- AddModuleScore(sceu, features = list(astro_down), name = "ADdown")
```

**Seurat对象 → SingleCellExperiment对象 → 使用Slingshot建轨迹+pseudotime**

```r
sce <- as.SingleCellExperiment(sceu)
reducedDim(sce, "UMAP") <- Embeddings(sceu, "umap")
clus <- sceu$seurat_clusters
# 根据上回的经验，直接用更ADdown的细胞做起始cluster
score <- sceu$ADdown1 - sceu$ADup1
tab0 <- data.frame(cl = clus, score = score, group = sceu$group) %>%
  group_by(cl) %>%
  summarise(score_med = median(score, na.rm = TRUE),
            nc_prop   = mean(group == "NC", na.rm = TRUE),
            n = n(), .groups="drop") %>%
  arrange(desc(score_med), desc(nc_prop))
start_clus <- as.character(tab0$cl[1])
# slingshot
sce <- slingshot(
  sce,
  clusterLabels = "seurat_clusters",
  reducedDim = "UMAP",
  start.clus = start_clus
)
# UMAP + 轨迹曲线
plot(reducedDim(sce, "UMAP"), col = "grey80", pch = 16, cex = 0.4,
     xlab = "UMAP_1", ylab = "UMAP_2")
lines(SlingshotDataSet(sce), lwd = 2, col = "black")
# pseudotime（如果多条轴，先用第一条/主线）
pt_mat <- slingPseudotime(sce)
cw_mat <- slingCurveWeights(sce)
sceu$pseudotime_sling <- pt_mat[, 1]
```

![细胞轨迹test10](/upload/md-image/other/细胞轨迹test10.png){:width="600px" height="600px"}

```
> ncol(slingPseudotime(sce))
[1] 4
> table(sceu$seurat_clusters)
   0    1    2    3    4    5    6    7    8 
1799 1457  805  621  545  476  427  184  117 
```

这说明有4条可行的主路径（分支或不同终点），同时UMAP图中的曲线有交叉和回环，可能是因为UMAP的几何会扭曲全局结构（因此也有一种做法是在PCA空间中进行Slingshot），同时cluster分的较细且彼此连接关系复杂，导致Slingshot会给出多条可能路径，这里通常就需要选一条“最像反应性/激活轴”的主线来解释，这里为了简单测试就直接取了第一条，如果想认真选的话，可以用cellWeights统计每条lineage覆盖的细胞数，选覆盖最多的一条当主线，并只用这一条做后面的tradeSeq

```r
# pseudotime是否与ADup/ADdown对齐
FeaturePlot(sceu, "pseudotime_sling") | VlnPlot(sceu, "pseudotime_sling", group.by = "group", pt.size = 0)
# 模块分数随pseudotime的趋势（辅助解释轨迹方向）
df <- FetchData(sceu, vars = c("pseudotime_sling","group","ADup1","ADdown1")) %>%
  filter(!is.na(pseudotime_sling))
df_long <- df %>%
  pivot_longer(cols = c("ADup1","ADdown1"), names_to = "module", values_to = "score") %>%
  mutate(pt_bin = ggplot2::cut_number(pseudotime_sling, n = 30))
sum_tab <- df_long %>%
  group_by(group, module, pt_bin) %>%
  summarise(
    pt_mid = mean(pseudotime_sling),
    score_mean = mean(score),
    n = n(),
    .groups = "drop"
  ) %>%
  filter(n >= 50)  # 可改 30/50/100
p1 <- ggplot(sum_tab, aes(x = pt_mid, y = score_mean, color = group)) +
  geom_line() +
  geom_point(aes(size = n), alpha = 0.8) +
  facet_wrap(~module, scales = "free_y") +
  theme_classic() +
  guides(size = "none")
# 样本级分析
meta <- FetchData(sceu, vars = c("pseudotime_sling","group","orig.ident")) %>%
  filter(!is.na(pseudotime_sling))
sample_tab <- meta %>%
  group_by(orig.ident, group) %>%
  summarise(pt_median = median(pseudotime_sling),
            pt_mean = mean(pseudotime_sling),
            .groups="drop")
wilcox.test(pt_median ~ group, data = sample_tab)
p2 <- ggplot(sample_tab, aes(x = group, y = pt_median)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.15, height = 0) +
  theme_classic()
p1 | p2
```

![细胞轨迹test11](/upload/md-image/other/细胞轨迹test11.png){:width="800px" height="800px"}

![细胞轨迹test12](/upload/md-image/other/细胞轨迹test12.png){:width="800px" height="800px"}

这里的结果和上面monocle3的类似（AD与NC的细胞分布存在偏移，并且与ADup/ADdown模块分数呈一致的趋势变化），说明选的这条线路很可能是在刻画“稳态 → 反应/应激”的连续变化

---

**tradeSeq**：轨迹上“变化基因”与“AD/NC 曲线不同”的基因

```r
# 准备counts+选择基因集合（这里作为测试只使用HVG）
use_genes <- VariableFeatures(sceu)
counts <- GetAssayData(sceu, slot = "counts")[use_genes, ]
# 过滤NA
pt1 <- pt_mat[, 1, drop = FALSE]
cw1 <- cw_mat[, 1, drop = FALSE]
keep <- !is.na(pt1[,1]) & (cw1[,1] > 0)
counts2 <- counts[, keep]
pt1_2   <- pt1[keep, , drop = FALSE]
cw1_2   <- cw1[keep, , drop = FALSE]
cond2   <- factor(sceu$group[keep])
# 拟合GAM
cond <- sceu$group
set.seed(1)
gam <- fitGAM(
  counts = counts2,
  pseudotime = pt1_2,
  cellWeights = cw1_2,
  conditions = cond2,
  nknots = 6,
  verbose = TRUE
)
# 哪些基因沿轨迹变化（不分组）
asso <- associationTest(gam)
asso <- asso[order(asso$pvalue), ]
# 哪些基因在轨迹上AD/NC曲线不同
ct <- conditionTest(gam)
ct <- ct[order(ct$pvalue), ]
```

- `associationTest`：找沿轨迹变化的基因（基础轨迹信号）
- `conditionTest`：找“同一轨迹位置上，AD-NC表达曲线不同”的基因（疾病差异）

```
> head(asso, 10)
            waldStat df pvalue meanLogFC
KCNIP4     2119.4446 11      0 1.1746620
CSMD1      1911.0154 11      0 1.1147822
SYT1       1920.7033 11      0 1.3592505
AC109466.1  266.5855 11      0 1.2754283
ATRNL1     1310.6656 11      0 1.8489925
SNTG1      1336.8417 11      0 1.1888490
HS6ST3      996.8393 11      0 2.2509793
NRXN3      2272.4418 11      0 1.8331828
RIMS2      1343.5195 11      0 1.5773849
NEGR1       839.9709 11      0 0.7599727
> head(ct, 10)
         waldStat df pvalue
KCND2    90.97927  6      0
CADPS   117.12250  6      0
DPP10   170.40654  6      0
AGBL4   150.26273  6      0
MT-CO3   89.87541  6      0
MT-ATP6 208.06991  6      0
MT-CO2  148.37502  6      0
PHACTR1  99.24620  6      0
MT-ND3  196.30111  6      0
MT-ND4  118.87843  6      0
```

```r
# top基因在轨迹上的平滑曲线
top_asso <- rownames(asso)[1:6]
top_ct   <- rownames(ct)[1:6]
association_top_genes <- plotSmoothers(gam, counts, gene = top_asso, alpha = 1)
conditionTest_top_genes <- plotSmoothers(gam, counts, gene = top_ct, alpha = 1)
association_top_genes | conditionTest_top_genes
```

![细胞轨迹test13](/upload/md-image/other/细胞轨迹test13.png){:width="800px" height="800px"}

这里得到的top基因很多都是神经元/突触相关基因，可能是因为细胞集内混入了神经元/双细胞/环境RNA，或者技术差异（比如线粒体基因含量）的影响。如果后续要进行分析，可能要剔除掉有“污染/双细胞”的cluster
